# 为什么要对Apache Arrow使用Gandiva - 灰信网（软件开发博客聚合）
_凯利 Stirman 是战略与 CMO 的副总裁[Dremio](https://www.dremio.com/) 。_

在过去的三年中， [Apache Arrow](https://arrow.apache.org/)在一系列不同的开源社区中 Swift 普及。 仅在 Python 社区中，Arrow 每月就被下载超过 500,000 次。 Arrow 项目既是有关如何以高效方式表示数据以进行内存中分析的规范，又是一系列使用十几种语言的库，可用于 Arrow 列格式。

与大多数汽车制造商通过 OEM 变速器而不是自行设计和制造自己的变速器一样，Arrow 为项目提供了一种最佳方式来管理和处理内存中的数据，以应对各种分析工作负载，包括机器学习，人工智能，数据框架，和 SQL 引擎。

针对 Apache Arrow [的 Gandiva 计划](https://github.com/dremio/gandiva)是基于 LLVM 的 Arrow 的新执行内核。 Gandiva 为 Arrow 缓冲区的低级操作提供了显着的性能改进。 我们首先在[Dremio 中](https://www.dremio.com/)包含了这项工作，以提高平台上分析工作负载的效率和性能，这些功能将被 Dremio 3.0 的用户使用。 在这篇文章中，我将描述该倡议的动机，实施细节，一些性能结果以及一些未来计划。

名称上的注释：Gandiva 是神话般的弓箭，出自印度史诗_《_摩 ab _婆罗多》_ ，由英雄阿朱纳（Arjuna）使用。 根据故事，甘地瓦是坚不可摧的，它使射出的箭的力量提高了千倍。

## 了解 Apache Arrow

在过去的几十年中，数据，数据库和数据分析发生了巨大变化。 这些更改背后的原因有很多：

-   组织对分析和使用数据的要求越来越复杂。 以及越来越高的查询性能标准。
-   内存已经变得便宜，可以基于内存中的分析启用一套新的性能策略。
-   CPU 和 GPU 的性能有所提高，但也已经发展到可以并行优化数据的处理。
-   针对不同用例出现了新型的数据库，每种都有其自己的存储和索引数据的方式。
-   已经出现了新的学科，包括数据工程和数据科学，每种学科都有数十种新工具来实现特定的分析目标。
-   列式数据表示已成为分析工作负载的主流，因为它们在速度和效率方面都具有显着的优势。

考虑到这些趋势，为现代开放标准提供了明显的机会，该标准涵盖了内存表示和每个引擎可以使用的相关低级数据处理库。 该标准应利用现有的所有新性能策略，并使跨平台的数据共享无缝且高效。 这是 Apache Arrow 的目标。

打个比方，考虑在欧盟之前度假去欧洲旅行。 要在 7 天内访问五个国家，您可以指望您要在边境花费几个小时进行护照检查，并且您将在货币兑换中损失一些钱这一事实。

这就是在没有 Arrow 的情况下处理内存中数据的方式。 存在对序列化和反序列化数据结构的极大低效，并且在此过程中进行了复制，浪费了宝贵的内存和 CPU / GPU 资源。 相比之下，艾罗就像是继欧盟和欧元之后访问欧洲。 您无需在边境等待，到处都使用一种货币。

Arrow 将列式数据结构的优点与内存中计算相结合。 它提供了这些现代技术的性能优势，同时还提供了复杂数据和动态模式的灵活性。 它以开放和标准化的方式完成所有这些工作。

了解 Apache Arrow 本身不是存储或执行引擎很重要。 与您所安装的系统相反，Apache Arrow 是一个库，它旨在用作以下类型系统的共享基础：

-   数据分析系统（例如 Pandas 和 Spark）
-   流和排队系统（例如 Kafka 和 Storm）
-   存储系统（例如 Parquet，Kudu，Cassandra 和 HBase）
-   SQL 执行引擎（例如 Drill 和 Impala）

Arrow 包含许多旨在集成到存储和执行引擎中的连接技术。 艾睿电子的关键组件包括：

-   **定义的数据类型集** ：SQL 和 JSON 类型，例如 Int，BigInt，Decimal，VarChar，Map，Struct 和 Array。
-   **规范表示** ：数据的柱状内存表示形式，用于支持在定义的数据类型之上构建的任意复杂的记录结构。
-   **通用数据结构** ：可识别箭头的伴随数据结构，包括选择列表，哈希表和队列。
-   **进程间通信** ：进程在共享内存，TCP / IP 和 RDMA 中进行通信。
-   **数据库** ：用于以多种语言（包括 Java，C ++，Python，Ruby，Rust，Go 和 JavaScript）读写列式数据的库。
-   **管道和 SIMD 算法** ：用于各种操作的算法，包括位图选择，哈希，过滤，存储，排序和匹配。
-   **列内存压缩** ：一系列提高内存效率的技术。
-   **内存持久性工​​具** ：通过非易失性内存，SSD 或 HDD 进行短期**持久性的工具** 。

## Gandiva for 阿帕奇箭

今年早些时候，Dremio 的团队为 Apache Arrow 开源了 Gandiva。 这是基于 LLVM 的 Arrow 的新执行内核。 Gandiva 为 Arrow 缓冲区的低级操作提供了显着的性能改进。

Gandiva 是根据 Apache 许可获得许可的新开源项目，并在 GitHub 上公开开发。 它作为独立的 C ++ 库提供，可使用 LLVM 中的运行时代码生成高效地评估 Arrow 缓冲区上的任意表达式。 应用程序将表达式树提交给 Gandiva 编译器，后者将针对本地运行时环境进行编译。 然后将请求传递给 Gandiva 执行内核，该内核消耗并产生大量的 Arrow 缓冲区。

![](https://www.freesion.com/images/386/3d6db5000bee6099ce7b0b467371db5a.JPEG)
 德雷米奥

甘地瓦建筑。

## 甘地瓦表达文库

截至 2018 年 8 月，Gandiva 支持数百种表达式：过滤器和项目关系运算符以及 Arrow Math，Arrow Boolean 和 Arrow Dates and Times。 计划在项目的将来版本中使用更多表达。

## Gandiva 中的零分解和流水线

![](https://www.freesion.com/images/122/a79373181d4ccf749e978c50e6fc3822.JPEG)
 德雷米奥

Gandiva 中的零分解。

在 Gandiva 中实现的另一个优化是我们称为零分解的东西。 提交给 Gandiva 的表达式可能涉及具有空值的记录。 对于某些操作，我们知道对包含空值的表达式进行的许多操作的结果始终为空。 通过将值是否为空（有效性）与实际值（数据）分开，我们可以更有效地处理记录批。

通过这种优化，我们可以使用位图交集确定零位，这可以显着减少 CPU 的分支开销。 然后可以批处理和提交数据值，以便在现代 CPU 上进行高效的 SIMD 处理。 事实证明，这种语义在基于 SQL 的处理中非常普遍，因此这种优化实际上非常有效，尤其是对于基于 SIMD 和 GPU 的处理。

## Gandiva 中的矢量化和 SIMD

![](https://www.freesion.com/images/260/3e392814f360bdf4f085541070317594.JPEG)
 德雷米奥

Gandiva 中的向量化。

箭头存储器缓冲区已经很好地组织了 SIMD 指令。 根据硬件的不同，Gandiva 可以通过一次操作处理大量的值。 例如，考虑下图，您可能有两组 2 位值需要在一个运算中组合。

对于具有 AVX-128 指令的 CPU，Gandiva 可以在单个矢量化操作中处理八对这 2 个字节的值。 相反，具有 AVX-512 的处理器可以使用 Gandiva 在一次操作中处理四倍的值。 此优化是自动执行的，还有许多其他可行的方法。

## Gandiva 中的异步线程控制

在分析中，我们通常受内存容量的约束，然后完全受 CPU 吞吐量的性能限制（一旦您有足够的内存，CPU 就是瓶颈）。 历史上，系统通过创建更多线程来解决 CPU 的资源共享问题（因此将平衡资源的需求委派给了操作系统线程调度程序）。 这种方法面临三个挑战：

-   您对资源优先级的控制很弱或没有控制权。
-   随着并发性的增加，上下文切换将主导 CPU 利用率。
-   诸如心跳之类的高优先级集群协调操作可能会错过其调度要求，并导致集群内聚不稳定。

Gandiva 的设计允许在如何为每个请求分配资源方面提供更大的灵活性。 例如，假设您有三个不同的用户试图同时使用该系统，如下图所示。 假设单个内核有 11 个时间间隔，您可能希望以不同的方式为每个操作分配资源。

![](https://www.freesion.com/images/119/08e9abdd96fe91e5c8c6ad2a506b9707.JPEG)
 德雷米奥

Gandiva 中的异步线程。

为用户 1 分配了一个时间间隔，而为用户 3（例如，“高级” 用户）分配的资源比用户 1 或用户 2 明显多。由于 Dremio 异步处理作业，因此它可以定期重新访问每个线程以重新平衡可用资源给定系统中正在运行的作业的优先级。 时序基于我们定义的量子，该量子旨在确保处理器的大部分时间用于转发进度，而不是上下文切换。

Gandiva 在此模型下运行良好，从而允许系统异步运行。 为此，它允许完成少量​​工作单元，然后暂停调用代码。 这种模式使 Gandiva 既可以用于传统的同步引擎，也可以用于功能更强大的异步引擎。

## 甘地瓦语支持

我们构建了 Gandiva 以使其与许多不同的环境兼容。 C ++ 和 Java 绑定现已可供用户使用。 我们希望与社区合作为许多其他语言（例如 Python，Go，JavaScript 和 Ruby）生成绑定。

![](https://www.freesion.com/images/128/753db93e9149314bcaf42536edb535d0.JPEG)
 德雷米奥

Gandiva 中的语言支持。

为了使新的原语可在 Gandiva 中使用，核心 C ++ 库提供了许多独立于语言的功能（包括一致的跨语言表示树表达）。 从那里开始，所有数据都将以 Arrow 格式出现，这是基于 Arrow 在这些不同语言中使用的能力的基础上的。

## 使用 Gandiva 改善性能

一般而言，Gandiva 几乎不折不扣地提供了全面的性能优势。 首先，Gandiva 将大多数查询的编译时间缩短到不到 10 毫秒。 其次，在 Dremio 中，Gandiva 改进了创建和维护 Data Reflections 的性能，Dremio 的查询计划程序可以使用它创建更智能的查询计划，从而减少工作量，从而将查询加速几个数量级。

为了评估 Gandiva 的优势，我们比较了使用标准 Java 代码生成和通过 Gandiva 编译查询通过 Dremio 执行的 SQL 查询的性能。 请注意，使用现有的基于 Java 的查询编译获得的 Dremio 的性能与最新的 SQL 执行引擎相当。

我们选择了五个简单表达式，并记录了表达式评估时间，以处理 5 亿条记录的 JSON 数据集。 该测试在 Mac 台式机上运行（2.7 GHz 四核 Intel Core i7 和 16GB RAM）。

通常，SQL 表达式越复杂，使用 Gandiva 的优势就越大。

### 和

````null
SELECT max(x+N2x+N3x) FROM json.d500```

### 五列输出

```null
SELECTsum(x + N2x + N3x),sum(x * N2x - N3x),sum(3 * x + 2 * N2x + N3x),count(x >= N2x - N3x),count(x + N2x = N3x)FROM json.d500```

### 十个输出列

```null
SELECTsum(x + N2x + N3x),sum(x * N2x - N3x),sum(3 * x + 2 * N2x + N3x),count(x >= N2x - N3x),count(x + N2x = N3x),sum(x - N2x + N3x),sum(x * N2x + N3x),sum(x + 2 * N2x + 3 * N3x),count(x <= N2x - N3x)count(x = N3x - N2x)FROM json.d500```

### 案例10

```null
SELECT count(casewhen x < 1000000 then x/1000000 + 0when x < 2000000 then x/2000000 + 1when x < 3000000 then x/3000000 + 2when x < 4000000 then x/4000000 + 3when x < 5000000 then x/5000000 + 4when x < 6000000 then x/6000000 + 5when x < 7000000 then x/7000000 + 6when x < 8000000 then x/8000000 + 7when x < 9000000 then x/9000000 + 8when x < 10000000 then x/10000000 + 9else 10end)FROM json.d500```

### 案例100

Case-100与Case-10类似，但具有100个案例和三个输出列。

五个测试的结果显示在下表中。 如您所见，Grandiva将更简单的查询速度提高了4倍或更高。 对于最复杂的查询CASE-100，Grandiva的性能提高了90倍。

| 测试 | Java JIT的项目时间（秒） | LLVM的项目时间（秒） | Java JIT时间/ LLVM时间 |
| --- | --- | --- | --- |
| 和 | 3.805 | 0.558 | 6.81倍 |
| 五列输出 | 8.681 | 1.689 | 5.13倍 |
| 十个输出列 | 24.923 | 3.476 | 7.74倍 |
| 案例10 | 4.308 | 0.925 | 4.66倍 |
| 案例100 | 1361 | 15.187 | 89.61倍 |

Gandiva优化了内存处理
--------------

Gandiva是用于执行Arrow数据结构的优化处理的新方法，使对这些结构的数据处理更加高效。 这项工作是每个实现Arrow的应用程序否则都需要自己实现，从而重新发明了轮子。 Gandiva免费提供这些应用程序的速度提升。

From: [https://www.infoworld.com/article/3318121/why-you-should-use-gandiva-for-apache-arrow.html](https://www.infoworld.com/article/3318121/why-you-should-use-gandiva-for-apache-arrow.html) 
 [https://www.freesion.com/article/6987698066/](https://www.freesion.com/article/6987698066/)
````
